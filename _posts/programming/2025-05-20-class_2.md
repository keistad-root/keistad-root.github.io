--
title: C++ 클래스 생성자와 소멸자, 대입 연산
tags:
  - C++
  - Multithread
---

### 생성자와 소멸자

생성자와 소멸자를 선언하는 방법은 다음과 같다.
```
class ClassName {
public:
	ClassName();
	ClassName(std::string_view str);
	~ClassName();
private:
	std::string mStr;
};

ClassName::ClassName() {
	mString = "DEFAULT";
}

ClassName::~ClassName() { }
```
생성자는 객체의 생성 시에 멤버의 초깃값을 지정해주거나, 동작을 수행해주는 등의 생성 시 행동을 정하는 특수한 메서드이다.
생성자는 클래스 이름과 똑같이 설정해야 하며, 매개변수를 받을 수 있지만 값을 리턴하지 않는다.
인수로 아무것도 주지 않는 생성자를 디폴트 생성자라고 하는데, 매개변수를 지정하지 않거나, 모든 매개변수를 디폴트값으로 설정하면 디폴트 생성자가 된다.

생성자도 마찬가지로 클래스 내부에 선언만 하였으면 외부에서 정의해주어야 한다.
이 때 어떤 클래스 소속임을 나타내는 스코프 지정 연산자를 앞에 붙인 후 생성자를 정의해준다.

위와 같은 생성자를 객체에서 사용하기 위해서는 스택에 객체를 만들 때와 힙에 객체를 만들 때로 구분된다.
```
ClassName stackObject("STRING"); \\ 스택에 생성
ClassName* hipObject1 = new ClassName("STRING") \\ 힙에 생성
ClassName* hipObject2 = nullptr; \\ 널 포인터를 가리킴
hipObject2 = new ClassName("STRING"); \\ 힙에 생성 후 객체의 주소를 가리킴

delete hipObject1;
hipObject1 = nullptr;
delete hipObject2;
hipObject2 = nullptr;
```
스택에 객체를 생성할 때는 객체 뒤에 인자를 전달하여 생성자를 호출한다.
이 때 생성자를 다음과 같이 선언과 동시에 호출하거나 선언 이후 호출해서는 안된다.
```
ClassName object.ClassName("STRING");
ClassName object2;
object2.ClassName("STRING");
```
힙에 객체를 생성할 때는 곧바로 생성자를 호출하지 않을 수도 있다.
하지만 스택에 생성할 때는 선언할 때 생성자를 호출한다.
만약 포인터로 선언한 객체를 바로 초기화해주지 않을 경우 `nullptr`로 초기화 해주어야 안전하다.
그렇지 않으면 포인터가 무작위 값을 가져 예측할 수 없는 동작을 발생시켜 메모리에 손상을 줄 수 있다.
하지만 `nullptr`로 초기화 해 둔 경우 잘못된 메로리를 참조했다는 에러가 발생하여 에러를 찾아내기 쉽다.
그리고 객체를 동적으로 할당한 경우 반드시 `delete`로 해제해야 한다.
그렇지 않으면 메모리 누수가 발생할 수도 있어, 메모리 성능에 영향을 끼친다.

### 여러 생성자 

C++는 함수 오버로딩을 지원하기 때문에 같은 이름의 메서드를 매개변수를 다르게 하여 여러 메서드를 생성할 수 있다.
마찬가지로 생성자의 경우도 매개변수를 다르게 가져간다면 여러 생성자를 만들 수 있다.
```
class ClassName {
public:
	ClassName(std::string_vew str);
	ClassName(double num);
	ClassName(std::string_vew str, double num);
private:
	std::string mStr;
	double mNum;
};

ClassName::ClassName(std::string_view str) {
	mStr = str;
}
ClassName::ClassName(double num) {
	mNum = num;
}
ClassName::ClassName(std::string_view str, double num) {
	mStr = str;
	mNum = num;
}
```
이 때 다음과 같이 객체를 생성할 수 있다.
```
ClassName obj1("STRING");
ClassName obj2(69.74);
ClassName obj3("STRING", 69.74);
```
생성자가 여러개인 경우 다른 생성자를 생성자 내에서 호출할 수 있다.
하지만 이러한 경우 생성자 내부에 클래스의 임시 객체가 생성되어 기존 초기화 하려는 객체의 생성자가 호출되지 않는다.
그러나 문법 상 문제가 없어 아무런 에러가 발생하지 않기 때문에 에러를 탐지하기도 쉽지 않다.
단, 위임 생성자를 사용하면 같은 클래스에서 생성자끼리 호출할 수 있다.

## 디폴트 생성자

