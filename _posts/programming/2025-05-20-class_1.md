--
title: C++ 클래스
tags:
  - C++
  - Multithread
---

클래스는 다음과 같이 정의할 수 있다.
```
class ClassName {
public:
	void setValue(double value);
	double getValue() const;
private:
	double mValue;
};
```
이 때 클래스 정의는 문장이므로 반드시 세미콜론을 붙여주어야 한다.
클래스 내부에는 변수나 함수 등이 선언될 수 있는데, 이러한 변수나 함수를 멤버라고 한다.
그리고 멤버 중 메서드, 생성자, 소멸자와 같은 것들을 멤버 함수, 열거형, 타입 앨리어스, 중첩 클래스와 같은 변수를 멤버 변수라고 한다.
멤버 변수는 데이터 멤버라고 부르기도 한다.

멤버는 클래스에 대한 인스턴스인 객체 단위로 적용된다.
하지만 정적 멤버의 경우 예외적으로 클래스 단위로 적용된다.
클래스에 선언될 수 있는 멤버의 개수에는 제헌이 없으며, 데이터 멤버와 멤버 함수의 이름이 같을 수도 있다.

클래스에는 멤버의 제한 범위를 설정하는 세 가지 접근 (제어) 제한자/지정자가 있는데, 각각 public, protected, private이다.
한 번 접근 제헌자가 지정되면 다른 지정자로 변경되기 전까지 모든 멤버에 적용된다.
public 제한자는 지정된 멤버에 어디에서나 접근할 수 있게 만드는 것으로, 보통 클라이언트가 사용할 메서드나 private나 protected 멤버에 접근하기 위한 메서드(게터와 세터)로 사용된다.
protected 제한자는 지정된 멤버에 같은 클래스로 된 객체의 멤버 함수로 접근할 수 있다. 
그리고 자식 클래스의 멤버함수로도 부모 클래스의 protected 멤버에 접근할 수 있게 한다.
보통 외부 클라이언트가 사용하면 안되는 헬퍼 메서드에 적용한다.
private 제한자는 같은 클래스의 멤버로만 접근할 수 있게 만든 것으로 자식 클래스에서 접근이 불가능하다.
기본적으로 public과 protected 멤버를 제외한 전부 private로 지정해야 한다.

클래스 내에서 아무 접근 제어도 지정하지 않으면 기본적으로 private로 설정된다.
그에 반해 구조체의 경우 접근 제어를 지정하지 않으면 public으로 설정된다.
이처럼 디폴트 접근 제한자가 다른 것을 제외하면 클래스와 구조체의 차이는 존재하지 않는다.
다만 관례상 메서드가 없거나 개수가 적다면 클래스보다는 구조체를 선호하는 편이다.

이러한 접근 제한자와 멤버는 선언하는 순서가 따로 존재하지 않고 심지어 접근 제헌자를 반복해서 지정하여도 된다.
하지만 가독성을 위해 접근 제한자 별로 묶어서 선언하는 것을 권장한다.

클래스를 정의할 때 멤버 변수를 선언하는 동시에 초기화 할 수 있는 데, 이를 멤버 이니셜라이저라고 한다.
간단하게 멤버 선언 시 초기값을 지정해주면 된다.
```
double mValue = 0;
```

클래스 내부에 선언만 된 메서드는 아직 정의 되지 않았다.
따라서 클래스 외부에서 해당 함수를 정의하여야 하며, 다음과 같이 정의한다.
```
void ClassName::setValue(double value) {
	mValue = value;
}

double ClassName::getValue() const {
	return mValue;
}
```
이 때 메서드 이름 앞에 클래스 이름과 스코프 지정 연산자(::)가 붙은 것을 확인할 수 있다.

클래스를 정의할 때는 헤더 파일과 소스 파일로 구분하여, 헤더 파일에서는 클래스를 정의하고, 소스 파일에서는 클래스의 멤버 함수들을 정의하는 방식을 주로 사용한다.
이 때 헤더 파일의 이름은 클래스 이름으로 저장하는 것을 권장한다.
소스 파일에는 헤더 파일과 연결시켜 주기 위해서 헤더 파일을 불러와야 한다.
따라서 상단에 `#include`문을 이용해서 다음과 같이 적어두어야 한다.
```
#include "ClassName.hpp"
```

앞서 private로 지정된 멤버는 외부에서 접근할 수 없는데, public 멤버를 통해 간접적으로 접근할 수 있다.
예를 들어 `setValue` 메서드를 호출하면 데이터 멤버 `mValue`의 값을 변경 가능하고, `getValue` 메서드를 호출하면 `mValue` 값을 불러올 수 있다.

클래스 내부에 정의된 메서드 내에서 같은 클래스에 정의된 다른 메서드도 호출가능하다.
메서드를 호출하면 메서드가 속한 객체의 포인터인 `this`가 매개변수 형태로 전달된다.
`this` 포인터를 이용해서 객체의 데이터 멤버와 메서드에 접근할 수 있고, 다른 메서드나 함수에 매개변수로 전달할 수도 있다.
주요 사용처로, 변수의 이름을 명확히 구분하는 용도로 사용할 수 있다.
예를 들어 데이터 멤버가 `value`라고 명명되었고, 메서드가 받는 매게 변수도 `value`로 명명되었다.
이 때 `this` 포인터를 이용해서 데이터 멤버에 접근할 수 있다.
```
void ClassName::setValue(double value) {
	this->value = value;
}
```
또 어떤 객체의 메서드 안에서 다른 객체의 메서드나 함수를 호출하는 과정에서 그 객체의 포인터를 전달할 때도 사용한다.
예를 들어
```
void print(const ClassName* name) {
	std::cout << name.getString() << std::endl
}
void ClassName::setValue(double value) {
	this->value = value;
	print(*this);
}
```
클래스에서 객체를 생성하기 위해서는 클래스 타입의 변수를 선언해야 한다.
이 때 하나의 클래스를 이용해서 객체를 여러 개 생성할 수 있다.
클래스의 메모리 상 생성 위치에 따라 두 가지 방식으로 생성할 수 있다.
먼저 다음과 같이 스택에 생성 가능하다.
```
ClassName object1, object2;
object.setValue(6);
object2.setValue(8.2);
std::cout << object.getValue() << std::endl;
std::cout << objec2.getValue() << std::endl;
```
객체를 생성하는 방법은 변수 타입이 클래스의 이름으로 한 변수 선언 방식과 같다.
그리고 객체 뒤에 닷 연산자(.)를 이용해서 public 멤버에 접근할 수 있다.
데이터 멤버도 public에 선언되었다면 닷 연산자를 통해 접근할 수 있다.

객체를 생성하는 또 하나의 방법으로 `new`를 이용해서 힙 메모리에 동적으로 할당할 수 있다.
```
ClassName* object1 = new ClassName();
object1->setValue(24);
std::cout << object1->getValue() << std::endl;
std::cout << (*object1).getValue() << std::endl;

delete object1;
object1 = nullptr;
```
이 때 화살표 연산자(->)로 접근하는 데, 이것은 역참조 연산자(*)과 닷 연산자(.)를 합친 것이다.
힙에 할당된 메모리는 용도가 끝나면 반드시 delete를 이용해서 메모리를 해제해야 한다.