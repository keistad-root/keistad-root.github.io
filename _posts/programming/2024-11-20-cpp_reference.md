---
title: C++ 레퍼런스
tags:
  - C++
  - Multithread
---

C++ 프로그래밍을 하면서 포인터와 레퍼런스를 능수능란하게 다루는 것은 중요하다.
포인터나 레퍼런스를 적절하게 다루는 것으로 메모리의 공간과 시간적인 효율을 극대화할 수 있다.
하지만 포인터나 레퍼런스를 사용은 상황에 따라 달라진다.
여기서는 레퍼런스가 무엇인지 알아보고 포인터와 레퍼런스에 대해서 논해볼 것이다.

레퍼런스란 어떤 변수에 대해서 새로운 별명을 붙여주는 것이다.
어떤 변수에 별명을 정해준 뒤 그 별명을 통해 수정해주면, 그 변수 값이 달라진다.
즉, 변수명과 레퍼런스 모두 해당 변수를 가지고 있는 것과 같다.
레퍼런스의 활용도는 많은 데, 변수를 레퍼런스로 만들 수 있고, 따라서 당연히 클래스의 데이터 멤버를 레퍼런스로 선언할 수 있다.
그리고 함수나 메서드가 레퍼런스를 매개변수로 받거나 레퍼런스를 리턴하게 만들 수도 있다.

## 레퍼런스 변수
먼저 레퍼런스를 이용해서 변수를 가리키는 것을 확인해보자.
레퍼런스 변수는 다음과 같이 사용할 수 있다.
```
int x = 7;
int& ref = x;
```
이 때 `ref`를 통해서 값을 바꾸면 `x`에 저장된 값이 바뀐다.
```
ref = 10;
std::cout << x << std::endl; \\ 10
```
레퍼런스 변수의 경우 생성하자 마자 바로 초기화되어야 한다.
레퍼런스 변수가 초기화되지 않았다면, 컴파일 단계에서 에러가 발생한다.
```
int& ref; // Compile Error
```
리터럴들과 같이 이름이 없는 우변수값에 대해서는 레퍼런스를 생성할 수 없다. 
왜냐하면 상수들은 non-const 레퍼런스이기 때문이다.
그래서 레퍼런스에 `const`를 취해주면 우변수값에 대해서 레퍼런스를 생성할 수 있다.
```
int& ref1 = 19; // Compile Error
const int& ref2 = 7; // 7
```
이것은 임시 객체에 대해서도 마찬가지 인데, 다음과 같이 `std::string` 객체를 리턴하는 함수가 있다고 하자.
```
std::string getString() { return "Hello"; }
```
이 때 이 값을 저장하기 위해서는 반드시 상수 레퍼런스여야 한다.
```
std::string& string1 = getString(); // Compile Error
cosnt std::string& string2 = getString(); // Hello
```
### 레퍼런스의 대상
레퍼런스는 처음 초기화 시 가리키기로 정해진 변수를 바꿀 수 없다.
레퍼런스에 다른 변수를 대입하면 레퍼런스가 다른 변수를 가리키는 것이 아니라 레퍼런스가 가리키던 변수가 다른 변수의 값으로 바뀐다.
예를 들어
```
int x = 7, y = 10;
int& xRef = x;
xRef = y; // x = 10
```
로 `xRef` 변수는 `x` 변수를 가리키고 그 값은 10이 된다.
여기서 y의 주소를 대입하면, xRef가 y를 가리키는 것이 아니라 컴파일 에러가 발생한다.
레퍼런스에 다른 레퍼런스를 대입하더라도 다른 레퍼런스는 값을 가리키기 때문에 레퍼런스에 단순히 대입하게 된다.
```
int x = 7, y = 10;
int& xRef = x;
int& yRef = y;
xRef = yRef; // xRef는 x를 가리키고 그 값은 10이다.
```
### 포인터와 레퍼런스
만약 레퍼런스를 가지고 주소를 불러온다면 그것은 레퍼런스의 주소가 아니라 레퍼런스가 가리키는 변수의 주소이다.
포인터는 변수의 주소가 저장되어 있으므로 레퍼런스의 주소와 포인터는 서로 타입이 같다.
예를 들어
```
int x = 7;
int& ref = x;
int* ptr = &x;
ptr == &ref; // true
```
에서, `ptr` 값과 `ref`의 주소는 서로 같으므로 참이다.

포인터와 레퍼런스에 대한 관계로 레퍼런스는 포인터 타입을 가리킬 수 도 있다. 
다음 예제를 보자
```
int* pointer;
int*& reference = pointer;
reference = new int;
*pointer = 5;
```
여기서 `*&`는 포인터에 대한 레퍼런스를 정의해 준 것이다.
즉, `reference`를 수정하면 `pointer`의 값이 바뀐다.
이와 같은 포인터에 대한 레퍼런스는 레퍼런스 매개변수의 경우 처럼 상황에 따라 유용하게 쓰일 수 있다.
이 때 주의할 점은 레퍼런스에 대한 레퍼런스는 선언할 수 없다.
즉, 다음의 경우들은 불가능하다.
```
int&& var1;
int&* var2;
```

### 레퍼런스 데이터 멤버
클래스의 데이터 멤버도 레퍼런스로 정의 가능하다.
하지만 앞서 언급되었듯이 레퍼런스는 반드시 다른 변수를 가리키고 있어야 한다.
따라서 레퍼런스 데이터 멤버는 객체 생성과 동시에 초기화되어야 한다.
에를 통해 알아보자.
```
class TempClass {
private:
	int& mRef;
public:
	TempClass(const int val) : mRef(val) { }
};
```
이 코드에서 `TempClass`가 생성될 때 `val`을 매개변수로 받으면 생성자 이니셜라이저를 통해 `mRef`의 값을 바로 지정해준다.
이처럼 레퍼런스 매개 변수는 생성자 이니셜라이저를 통해서 반드시 지정해 주어야 한다.
생성자 본문에서 레퍼런스 매개 변수를 지정할 수 없다.
이 때 마찬가지로 레퍼런스를 초기화하였으면 그 레퍼런스가 가리키는 대상을 변경할 수 없다.

## 레퍼런스 매개변수
사실 레퍼런수로 변수를 선언하기 보다 해당 변수를 직접 사용하는 것이 직관적이다.
마찬가지로 레퍼런스 데이터 멤버를 단독으로 사용하는 것 보다 일반적인 데이터 멤버를 사용하는 것이 더 편리하다.
그럼에도 불구하고 레퍼런스를 사용하는 가장 큰 이유는 레퍼런스 매개변수이다.
일반적인 경우 함수가 매개변수를 받으면 기존 스택 위에 새로운 스택을 만든 다음 기존 스택의 변수들을 복사하여 새로운 스택에 새로 정의한다.
이렇게 하면 해당 변수를 변경하더라도 새로운 스택에 정의된 변수만 영향을 받고 기존 스택의 변수는 영향을 받지 않는다.
하지만 레퍼런스 매개변수를 사용하면 레퍼런스가 기존 스택의 변수를 가리키고 있다.
따라서 새로운 스택에서 변수를 변경하면 기존 스택의 변수가 영향을 받는다.
예를 들어 두 `int` 값을 받아 서로 값을 바꾸는 함수를 만든다고 생각해보자.
```
void swap(int& x, int& y) {
	int temp = x;
	x = y;
	y = temp;
}
```
이렇게 하면 `swap` 함수에 넣은 변수 두 개를 레퍼런스를 이용하여 서로 값을 바꿀 수 있다.
```
int x = 7, y = 10;
swap(x, y); // x = 10, y = 7
```
레퍼런스 변수가 상수로 초기화 될 수 없듯이 non-const 레퍼런스 매개변수의 경우 상수를 매개변수로 전달하는 것은 불가능하다.

레퍼런스로 매개변수를 전달하는 경우 또 다른 장점이 있다.
바로 레퍼런스가 기존 스택의 변수를 직접 가리키므로 함수 안에서 새로 복제품을 만들지 않는다.
이를 통해 클래스나 스트럭트의 객체 같은 큰 덩어리를 복제하는 데 걸리는 시간을 들이지 않게 된다.
그리고 코드가 명확히 구현되지 않는 경우 복제 시 깊은 복사가 이뤄지지 않을 수도 있는데, 레퍼런스를 사용하면 애초에 내용을 복사하지 않으므로 코드의 정확성을 보장할 수 있다.
이러한 효율과 정확도 때문에 레퍼런스를 사용하는 데 원본의 내용을 변경하고 싶지 않을 수 있다.
이런 경우 `const` 키워드를 이용하여, 상수 레퍼런스를 전달해주면 된다.
즉 경우에 따라 `int`와 `double` 같은 기본타입이 함수 안에서 수정할 필요가 없을 경우 기존 전달 방식을 이용하고, 나머지의 경우는 변경 여부에 따라 레퍼런스 전달 방식이나 상수 레퍼런스 전달 방식을 적절하게 이용해주면 좋은 코드를 개발할 수 있다.

### 포인터를 레퍼런스로 전달
포인터를 사용하여 객체를 생성하고 코드를 다루다가 어떤 함수에 포인터를 전달해야 하는 경우가 생길 수 있다.
그 함수가 포인터를 매개변수로 받는다면 상관이 없지만 해당 기능을 하는 함수가 레퍼런스만 매개변수로 전달 받는 경우를 생각해보자.
이런 경우에도 해당 값을 전달하는 방법이 있다.
앞서 레퍼런스의 주소는 포인터라고 하였으므로 포인터를 역참조하면 또 다른 레퍼런스이다.
그래서 다음과 같이 전달이 가능하다.
```
int x = 7, y = 10;
int* xPtr = &x, yPtr = &y;
swap(*xPtr, *yPtr);
```

## 레퍼런스 리턴값
함수나 메서드의 리턴값도 레퍼런스 타입으로 지정할 수 있다.
하지만 이 때 함수나 메서드의 범위를 벗어나더라도 사라지자 않는 객체의 경우에 가능하다.
사라지지 않고 남아있는 객체의 경우 레퍼런스 타입으로 반환하면 새로 복사하지 않으므로 효율과 정확성이 증가한다.

물론 이동 의미론을 지원하는 함수의 경우 값을 리턴해도 레퍼런스로 리턴하는 것 만큼 효율적이다. 
그리고 리턴값을 좌측값에 직접 대입할 때도 레퍼런스로 리턴한다.

## 우측값 레퍼런스
좌측값은 이름과 주소를 가지면서 대입문의 왼쪽에 나온다. 
그와 반대로 우측값은 일반적으로 대입문의 오른쪽에 나오는 값으로 리터럴, 임시 객체, 값과 같이 좌측값이 아닌 것들을 가리킨다.
예를 들어
```
int a = 7 * 8;
```
에서 `a`는 좌측값이고 이름을 가져올 수 있고 `&a`로 주소를 가져올 수 있다.
반면 `7 * 8`은 우측값으로 주소가 없고 해당 문장 이후로 삭제된다.
우측값 레퍼런스는 우측값이 임시 객체일 때 적용되는 개념이다.
이는 임시 객체에 적용할 함수를 컴파일러가 선택하기 위해 사용된다.
즉 우측값 레퍼런스로 구현이 되면 객체를 복사해야 할 경우 컴파일러는 해당 값이 임시 객체라는 점을 이용해서 우측값에 대한 포인터를 복사하는 방식으로 실행된다.
어떤 임의의 함수가 있다고 하자.
```
void print(std::string& str) {
	std::cout << "Print: " << str << std::endl;
}
```
이 경우 다음과 같은 함수 이용이 불가능하다.
```
print("Hello World");

std::string a = "Hello ";
std::string b = "World";
print( a + b );
```
왜냐하면 `"Hello Wrold"`는 리터럴이므로 우측값이며, `a + b`는 임시값으로 우측값이기 때문이다.
따라서 다음과 같이 매개변수가 우측값 레퍼런스인 함수가 따로 정의되어 있어야 한다.
```
void print(std::string&& str) {
	std::cout << "Print: " << str << std::endl;
}
```
우측값 레퍼런스는 타입 뒤에 `&&`를 붙여서 전달해줄 수 있다.

## 포인터와 레퍼런스
레퍼런스로 할 수 있는 일은 모두 포인터로 대체 가능하다.
그럼에도 불구하고 레퍼런스를 사용하는 이유는 몇 가지가 있다.
먼저 포인터를 사용할 경우 변수값에 접근하기 위해서는 변수마다 `*`을 붙여서 명시적으로 역참조를 해줘야 한다.
하지만 레퍼런스를 사용하면 변수 이름 만으로 코드를 깔끔하게 작성할 수 있다.
그리고 포인터의 경우 `nullptr`이 되어서 역참조 과정에서 에러가 발생할 수 있다.
하지만 레퍼런스는 널 값을 가질 수 없고 역참조가 불가능하다. 
따라서 레퍼런스를 사용하는 것이 포인터를 사용하는 것 보다 좀 더 안전하다.
하지만 이것은 코드에 포인터가 하나도 없을 때 레퍼런스의 안정성이 보장된다.
어떤 함수가 레퍼런스를 매개 변수로 받는 데, 포인터 변수를 집어넣어 준다고 하자.
그러면 포인터를 역참조 해서 함수에 넣어줘야 한다.
이러한 행위는 컴파일 단계에서 에러가 발생하지는 않지만 실행 과정에서 잘못된 값을 내보낼 수 있다.
실행 과정에서 잘못된 값을 내는 경우 굉장히 알아차리기가 어렵다.

이처럼 레퍼런스를 이용하면 코드를 더 간결하고 안전하게 작성할 수 있다.
포인터를 이용해서 코드를 작성할 수 있으면 대부분은 레퍼런스를 대신 사용할 수 있다.
객체에 대한 레퍼런스도 마찬가지로 다형성을 지원한다.
하지만 반드시 포인터를 사용해야 할 경우가 발생한다.
예를 들어 동적 할당 메모리의 주소는 포인터에 저장해야 가리키는 주솟값을 바꿀 수 있기 때문에 반드시 포인터로 저장해야 한다.
그리고 `optional` 타입의 경우 값이 `nullptr`이 될 수 있기 때문에 마찬가지로 포인터를 사용해야 한다.
또 다른 예로 컨테이너에 다형성 타입을 저장할 때도 포인터를 사용해야 한다.

포인터와 매개변수 중 어떤 것을 선택할 지에 대한 기준으로 메모리의 소유권이 어디 있는 지 따져보는 것이다.
메모리는 변수가 마지막으로 사용되는 위치에서 해제되어야 한다.
만약 메모리의 소유권이 변수를 받는 코드에 있으면 객체를 포인터로 표현한다.
하지만 다시 돌려 받는 등 소유권이 변수를 받는 코드에 귀속되지 않는 다면 레퍼런스로 전달해준다.
해당 기준이 너무 어려우면 되도록 레퍼런스로 처리하고 정 안되는 경우에 포인터를 사용하는 것이 바람직하다.